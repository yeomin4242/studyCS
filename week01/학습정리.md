# 1주차 학습 정리: 디자인 패턴과 프로그래밍 패러다임

> **학습 기간**: 2025.09.01 ~ 2025.09.08
> **발표 일정**: 2025.09.09 (화) 18:30-19:30

## 📚 학습 내용 정리

### 1.1 디자인 패턴

#### 1.1.1 싱글톤 패턴 (Singleton Pattern)

**개념**
- 
![alt text](images/singleton.png)
싱글톤 패턴(singleton pattern)은 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴입니다. 

하나의 클래스를 기반으로 여러 개의 개별적인 인스턴스를 만들 수 있지만, 그렇게 하지 않고 하나의 클래스를 기반으로 단 하나의 인스턴스를 만들어 이를 기반으로 로직을 만드는 데 쓰이며,보통 데이터베이스 연결 모듈에 많이 사용합니다.

**구현 방법**
-
Eager Init과 Lazy Init으로 크게 두 가지 방법이 존재합니다.
Lazy Init 시에 MultiThread 환경에서 Thread-safe 하지 않기 때문에, 이를 극복하기 위해서 여러 해결방법이 존재합니다.

<b>Eager Initialization</b>

``` java
public class Singleton {
    // Eager Initialization
    private static Singleton uniqueInstance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
      return uniqueInstance; 
    } 
}
```
- 장점
    - 클래스 로더에 의해 클래스가 최초 로딩 될 때 객체가 생성됨으로 Thread-safe합니다.
- 단점
    - 싱글톤객체 사용유무와 관계없이 클래스가 로딩되는 시점에 항상 싱글톤 객체가 생성되고, 메모리를 잡고있기 때문에 비효율적일 수 있습니다.

<b>Lazy initialization</b>

``` java
public class LazyInitialization {

	private static LazyInitialization instance;

	private LazyInitialization(){}

	public static LazyInitialization getInstance(){
		if(instance == null){
			instance = new LazyInitialization();
		}
		return instance;
	}

}
```

- 장점
    - 싱글톤 객체가 필요할 때 인스턴스를 얻을 수 있습니다.
    - Eager initialization 방식에 단점을 보완할 수 있습니다.(메모리 누수 방지)
- 단점
    - 만약 multi-thread 환경에서 여러 곳에서 동시에 getInstance()를 호출할 경우 인스턴스가 두번 생성될 여지가 있습니다.
    - 즉 multi-thread 환경에서는 싱글톤 철학이 깨질 수 있는 위험이 있습니다.

1. Thread safe Lazy initialization
```java
class Singleton {
    private static Singleton instance;

    private Singleton() {}

    // synchronized 메서드
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

- 장점
    - Lazy initialization 방식에서 thread-safe하지 않은 점을 보완합니다.
- 단점
    - synchronized 키워드를 사용할 경우 자바 내부적으로 해당 영역이나 메서드를 lock, unlock 처리하기 때문에 내부적으로 많은 cost가 발생합니다. 
    따라서 많은 thread 들이 getInstance()를 호출하게 되면 프로그램 전반적인 성능저하가 발생합니다.

2. Thread safe Lazy initialization+ Double-checked locking
``` java
class Singleton {
    private static Singleton instance;

    private Singleton() {}

    // synchronized 메서드
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

- 장점
    - synchronized 호출을 줄여서 성능저하를 조금 더 완화시킬 수 있습니다.
- 단점
    - 하지만 여전히 성능 저하를 회피할 수 없습니다.

3. Bill Pugh Solution(Initialization on demand holder idiom)
``` java
class Singleton {

    private Singleton() {}

    // static 내부 클래스를 이용
    // Holder로 만들어, 클래스가 메모리에 로드되지 않고 getInstance 메서드가 호출되어야 로드됨
    private static class SingleInstanceHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingleInstanceHolder.INSTANCE;
    }
}
```

- 장점
    - 내부클래스를 static으로 선언하였기 때문에, 싱글톤 클래스가 초기화되어도 SingleInstanceHolder 내부 클래스는 메모리에 로드되지 않습니다.
    - 어떠한 모듈에서 `getInstance()` 메서드를 호출할 때, SingleInstanceHolder 내부 클래스의 static 멤버를 가져와 리턴하게 되는데, 이때 내부 클래스가 한번만 초기화되면서 싱글톤 객체를 최초로 생성 및 리턴하게 됩니다.
   - 마지막으로 final 로 지정함으로서 다시 값이 할당되지 않도록 방지합니다.
- 단점
    - 클라이언트 사이드에서 파괴하는 방법을 막을 수 없습니다.
    - Reflection API (생성자에서 이미 인스턴스가 존재하는지 확인로 방어 가능)
    - 직렬화/역직렬화 (readResolve() 메서드로 기존 인스턴스 반환)



4. Enum initialization
``` java
public enum EnumSingleTon {

		INSTANCE;
		public void excute(String arg){
			//...code
		}
}
```
- 장점
    - enum은 애초에 멤버를 만들때 private로 만들고 한번만 초기화 하기 때문에 thread safe합니다.
    - enum 내에서 상수 뿐만 아니라, 변수나 메서드를 선언해 사용이 가능하기 때문에, 이를 이용해 싱글톤 클래스 처럼 응용이 가능합니다.
- 단점
    - 싱글톤 클래스를 멀티톤(일반적인 클래스)으로 마이그레이션 해야할때 처음부터 코드를 다시 짜야 되는 단점이 존재합니다.
    - 클래스 상속이 필요할때, enum 외의 클래스 상속은 불가능합니다.



**장점**
- 
하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 인스턴스를 생성할 때 드는 비용이 줄어드는 장점이 있습니다.

**단점**
- 
1. 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트 마다 '독립적인' 인스턴스를 만들기가 힘들어서, TDD 할 때 어려움을 겪을 수 있습니다. <br/>
=> 이를 어느정도 해결하기 위해 DI(Dependency Injection)을 이용하는 방안이 있습니다.

2. SOLID 원칙의 단일 책임 원칙(SRP)와 개방-폐쇄 원칙(OCP)에도 위배되고, 마지막으로 구체 클래스에 의존하게 되어서 의존 역전 원칙(DIP)에도 위배됩니다.

3. 모듈간 의존성이 높아집니다.

**사용 사례**
- 
1. 데이터 베이스 연결 모듈
2. 게임 개발 시 게임의 메인 흐름을 관리 및 제어하는 GameManager 클래스

**코드 예제**
```java
class Singleton {
    private static class singleInstanceHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    public static Singleton getInstance() {
        return singleInstanceHolder.INSTANCE;
    }
}

public class HelloWorld{ 
     public static void main(String []args){ 
        Singleton a = Singleton.getInstance(); 
        Singleton b = Singleton.getInstance(); 
        System.out.println(a.hashCode());
        System.out.println(b.hashCode());  
        if (a == b){
         System.out.println(true); 
        } 
     }
}
/*
705927765
705927765
true
```
```javascript
class Singleton {
    constructor() {
        if (!Singleton.instance) {
            Singleton.instance = this
        }
        return Singleton.instance
    }
    getInstance() {
        return this 
    }
}
const a = new Singleton()
const b = new Singleton() 
console.log(a === b) // true 
```

---

#### 1.1.2 팩토리 패턴 (Factory Pattern)

**개념**
- 

**구현 방법**
- 

**장점**
- 

**단점**
- 

**사용 사례**
- 

**코드 예제**
```java
// 팩토리 패턴 구현 예제
```

---

#### 1.1.3 전략 패턴 (Strategy Pattern)

**개념**
- 

**구현 방법**
- 

**장점**
- 

**단점**
- 

**사용 사례**
- 

**코드 예제**
```java
// 전략 패턴 구현 예제
```

---

#### 1.1.4 옵저버 패턴 (Observer Pattern)

**개념**
- 

**구현 방법**
- 

**장점**
- 

**단점**
- 

**사용 사례**
- 

**코드 예제**
```java
// 옵저버 패턴 구현 예제
```

---

#### 1.1.5 프록시 패턴과 프록시 서버 (Proxy Pattern)

**개념**
- 

**구현 방법**
- 

**장점**
- 

**단점**
- 

**사용 사례**
- 

**코드 예제**
```java
// 프록시 패턴 구현 예제
```

---

#### 1.1.6 이터레이터 패턴 (Iterator Pattern)

**개념**
- 

**구현 방법**
- 

**장점**
- 

**단점**
- 

**사용 사례**
- 

**코드 예제**
```java
// 이터레이터 패턴 구현 예제
```

---

#### 1.1.7 노출모듈 패턴 (Revealing Module Pattern)

**개념**
- 

**구현 방법**
- 

**장점**
- 

**단점**
- 

**사용 사례**
- 

**코드 예제**
```javascript
// 노출모듈 패턴 구현 예제 (JavaScript)
```

---

#### 1.1.8 MVC 패턴 (Model-View-Controller)

**개념**
- 

**구조**
- Model: 
- View: 
- Controller: 

**장점**
- 

**단점**
- 

**사용 사례**
- 

---

#### 1.1.9 MVP 패턴 (Model-View-Presenter)

**개념**
- 

**구조**
- Model: 
- View: 
- Presenter: 

**MVC와의 차이점**
- 

**장점**
- 

**단점**
- 

---

#### 1.1.10 MVVM 패턴 (Model-View-ViewModel)

**개념**
- 

**구조**
- Model: 
- View: 
- ViewModel: 

**특징**
- 

**장점**
- 

**단점**
- 

---

### 1.2 프로그래밍 패러다임

#### 1.2.1 선언형과 함수형 프로그래밍

**선언형 프로그래밍**
- **개념**: 
- **특징**: 
- **장점**: 
- **단점**: 

**함수형 프로그래밍**
- **개념**: 
- **핵심 원칙**: 
  - 순수 함수 (Pure Function): 
  - 불변성 (Immutability): 
  - 고차 함수 (Higher-order Function): 
- **장점**: 
- **단점**: 

**코드 예제**
```javascript
// 선언형 프로그래밍 예제

// 함수형 프로그래밍 예제
```

---

#### 1.2.2 객체지향 프로그래밍

**개념**
- 

**4가지 특징**
1. **추상화 (Abstraction)**
   - 

2. **캡슐화 (Encapsulation)**
   - 

3. **상속 (Inheritance)**
   - 

4. **다형성 (Polymorphism)**
   - 

**설계 원칙 (SOLID)**
- **S**: Single Responsibility Principle
  - 

- **O**: Open/Closed Principle
  - 

- **L**: Liskov Substitution Principle
  - 

- **I**: Interface Segregation Principle
  - 

- **D**: Dependency Inversion Principle
  - 

**장점**
- 

**단점**
- 

**코드 예제**
```java
// 객체지향 프로그래밍 예제
```

---

#### 1.2.3 절차형 프로그래밍

**개념**
- 

**특징**
- 

**장점**
- 

**단점**
- 

**객체지향과의 차이점**
- 

**코드 예제**
```c
// 절차형 프로그래밍 예제 (C언어)
```

---

#### 1.2.4 패러다임의 혼합

**혼합 사용의 이유**
- 

**혼합 사용 예시**
- 

**현대 언어의 멀티 패러다임**
- Java: 
- Python: 
- JavaScript: 
- Scala: 

---

## ❓ 학습한 질문과 답변

### Q1. 
**A**: 

### Q2. 
**A**: 

### Q3. 
**A**: 

---

## 🔗 참고 자료

### 도서
- 면접을 위한 CS 전공지식 노트 (1장)
- 

### 온라인 자료
- 
- 

### 추가 학습
- 
- 

---

## 📝 학습 후기

### 어려웠던 점
- 

### 새롭게 알게 된 점
- 

### 실무 적용 방안
- 

### 추가 학습 계획
- 

---

**작성일**: 2025.09.XX  
**최종 수정**: 2025.09.XX
